import { LLMModel, CostCalculation } from '@/types';
import { formatCurrency, formatDate, formatNumber } from './formatting';


interface ComparisonExportData {
  calculations: CostCalculation[];
  inputTokens: number;
  outputTokens: number;
  totalTokens: number;
}

interface UsageEstimateExportData {
  model: LLMModel;
  queriesPerDay: number;
  inputTokensPerQuery: number;
  outputTokensPerQuery: number;
  conversationHistoryTokens: number;
  dailyCost: number;
  monthlyCost: number;
  yearlyCost: number;
  withHistoryCosts?: {
    dailyCost: number;
    monthlyCost: number;
    yearlyCost: number;
  };
}

class PDFExporter {
  private doc: any;
  private autoTable: any;
  private pageHeight: number;
  private pageWidth: number;
  private margin = 20;
  private lastTableY = 0;

  async init() {
    // Import modules separately
    const jsPDFModule = await import('jspdf');
    const autoTableModule = await import('jspdf-autotable');
    
    const jsPDF = jsPDFModule.default;
    this.autoTable = autoTableModule.default;
    
    this.doc = new jsPDF();
    this.pageHeight = this.doc.internal.pageSize.height;
    this.pageWidth = this.doc.internal.pageSize.width;
  }

  private addWatermark() {
    const centerX = this.pageWidth / 2;
    const centerY = this.pageHeight / 2;
    
    this.doc.saveGraphicsState();
    this.doc.setGState(this.doc.GState({ opacity: 0.1 }));
    this.doc.setFontSize(60);
    this.doc.setTextColor(100, 100, 100);
    
    // Rotate text for diagonal watermark
    this.doc.text('LLM PRICE CALCULATOR', centerX, centerY, {
      angle: -45,
      align: 'center'
    });
    
    this.doc.restoreGraphicsState();
  }

  private addHeader(title: string, subtitle?: string) {
    // Add logo area (placeholder for now, could be replaced with actual logo)
    this.doc.setFillColor(59, 130, 246); // Blue
    this.doc.rect(this.margin, this.margin, 15, 15, 'F');
    
    // Add gradient effect simulation with multiple rectangles
    this.doc.setFillColor(139, 92, 246); // Purple
    this.doc.rect(this.margin + 3, this.margin + 3, 9, 9, 'F');

    // Calculator icon representation (simple squares)
    this.doc.setFillColor(255, 255, 255);
    for (let i = 0; i < 2; i++) {
      for (let j = 0; j < 2; j++) {
        this.doc.rect(this.margin + 5 + (i * 3), this.margin + 5 + (j * 3), 2, 2, 'F');
      }
    }

    // Main title
    this.doc.setFontSize(24);
    this.doc.setTextColor(30, 30, 30);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text(title, this.margin + 25, this.margin + 10);

    // App name
    this.doc.setFontSize(12);
    this.doc.setTextColor(100, 100, 100);
    this.doc.setFont('helvetica', 'normal');
    this.doc.text('Generated by LLM Price Calculator', this.margin + 25, this.margin + 18);

    if (subtitle) {
      this.doc.setFontSize(14);
      this.doc.setTextColor(60, 60, 60);
      this.doc.text(subtitle, this.margin, this.margin + 35);
    }

    // Add separator line
    this.doc.setDrawColor(200, 200, 200);
    this.doc.setLineWidth(0.5);
    this.doc.line(this.margin, this.margin + 45, this.pageWidth - this.margin, this.margin + 45);

    return this.margin + 55; // Return Y position for next content
  }

  private addFooter() {
    const footerY = this.pageHeight - 20;
    
    // Footer separator
    this.doc.setDrawColor(200, 200, 200);
    this.doc.setLineWidth(0.5);
    this.doc.line(this.margin, footerY - 5, this.pageWidth - this.margin, footerY - 5);

    // Footer content
    this.doc.setFontSize(10);
    this.doc.setTextColor(120, 120, 120);
    this.doc.setFont('helvetica', 'normal');
    
    // Left side - app info
    this.doc.text('LLM Price Calculator - Professional Cost Analysis Tool', this.margin, footerY);
    
    // Right side - timestamp
    const timestamp = new Date().toLocaleString();
    const timestampWidth = this.doc.getTextWidth(timestamp);
    this.doc.text(timestamp, this.pageWidth - this.margin - timestampWidth, footerY);

    // Center - page number
    const pageNum = `Page ${this.doc.getCurrentPageInfo().pageNumber}`;
    const pageNumWidth = this.doc.getTextWidth(pageNum);
    this.doc.text(pageNum, (this.pageWidth - pageNumWidth) / 2, footerY);
  }

  async exportModelComparison(data: ComparisonExportData): Promise<void> {
    await this.init();
    let yPos = this.addHeader('LLM Model Cost Comparison', 'Comprehensive analysis of selected models');
    this.addWatermark();

    // Summary section
    this.doc.setFontSize(16);
    this.doc.setTextColor(30, 30, 30);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Analysis Summary', this.margin, yPos);
    yPos += 10;

    this.doc.setFontSize(11);
    this.doc.setFont('helvetica', 'normal');
    this.doc.setTextColor(60, 60, 60);

    const summaryData = [
      `Input Tokens: ${formatNumber(data.inputTokens)}`,
      `Output Tokens: ${formatNumber(data.outputTokens)}`,
      `Total Tokens: ${formatNumber(data.totalTokens)}`,
      `Models Compared: ${data.calculations.length}`,
      `Analysis Date: ${formatDate(new Date())}`
    ];

    summaryData.forEach(item => {
      this.doc.text(item, this.margin, yPos);
      yPos += 6;
    });

    yPos += 10;

    // Model comparison table
    const tableData = data.calculations
      .sort((a, b) => a.totalCost - b.totalCost)
      .map(calc => ([
        calc.model.name,
        calc.model.provider,
        formatCurrency(calc.inputCost),
        formatCurrency(calc.outputCost),
        formatCurrency(calc.totalCost),
        `$${calc.model.inputPrice}/1M`,
        `$${calc.model.outputPrice}/1M`,
        formatNumber(calc.model.contextWindow)
      ]));

    this.autoTable(this.doc, {
      startY: yPos,
      head: [[
        'Model Name',
        'Provider',
        'Input Cost',
        'Output Cost',
        'Total Cost',
        'Input Price',
        'Output Price',
        'Context Window'
      ]],
      body: tableData,
      theme: 'striped',
      headStyles: {
        fillColor: [59, 130, 246],
        textColor: [255, 255, 255],
        fontStyle: 'bold',
        fontSize: 10
      },
      bodyStyles: {
        fontSize: 9,
        cellPadding: 3
      },
      columnStyles: {
        2: { halign: 'right' }, // Input Cost
        3: { halign: 'right' }, // Output Cost
        4: { halign: 'right', fontStyle: 'bold' }, // Total Cost
        5: { halign: 'right' }, // Input Price
        6: { halign: 'right' }, // Output Price
        7: { halign: 'right' } // Context Window
      },
      margin: { left: this.margin, right: this.margin },
      styles: {
        cellPadding: 3,
        fontSize: 9,
        overflow: 'linebreak'
      },
      didDrawPage: (data: any) => {
        this.lastTableY = data.cursor.y;
      }
    });

    // Cost efficiency analysis
    const finalY = this.lastTableY + 15;
    if (finalY < this.pageHeight - 60) {
      this.doc.setFontSize(14);
      this.doc.setFont('helvetica', 'bold');
      this.doc.setTextColor(30, 30, 30);
      this.doc.text('Cost Efficiency Analysis', this.margin, finalY);

      const mostEfficient = data.calculations.reduce((min, calc) => 
        calc.totalCost < min.totalCost ? calc : min
      );
      const mostExpensive = data.calculations.reduce((max, calc) => 
        calc.totalCost > max.totalCost ? calc : max
      );

      this.doc.setFontSize(11);
      this.doc.setFont('helvetica', 'normal');
      this.doc.setTextColor(60, 60, 60);

      const analysisText = [
        `Most Cost-Effective: ${mostEfficient.model.name} (${mostEfficient.model.provider}) - ${formatCurrency(mostEfficient.totalCost)}`,
        `Highest Cost: ${mostExpensive.model.name} (${mostExpensive.model.provider}) - ${formatCurrency(mostExpensive.totalCost)}`,
        `Cost Difference: ${formatCurrency(mostExpensive.totalCost - mostEfficient.totalCost)} (${((mostExpensive.totalCost / mostEfficient.totalCost - 1) * 100).toFixed(1)}% more expensive)`
      ];

      let analysisY = finalY + 10;
      analysisText.forEach(text => {
        this.doc.text(text, this.margin, analysisY);
        analysisY += 8;
      });
    }

    this.addFooter();
    this.doc.save(`LLM_Model_Comparison_${new Date().toISOString().split('T')[0]}.pdf`);
  }

  async exportUsageEstimate(data: UsageEstimateExportData): Promise<void> {
    await this.init();
    let yPos = this.addHeader('LLM Usage Cost Estimate', `${data.model.name} - ${data.model.provider}`);
    this.addWatermark();

    // Model details section
    this.doc.setFontSize(16);
    this.doc.setTextColor(30, 30, 30);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Model Information', this.margin, yPos);
    yPos += 15;

    // Model details in a clean layout
    const modelDetails = [
      ['Model Name', data.model.name],
      ['Provider', data.model.provider],
      ['Input Price', `$${data.model.inputPrice}/1M tokens`],
      ['Output Price', `$${data.model.outputPrice}/1M tokens`],
      ['Context Window', formatNumber(data.model.contextWindow)],
      ['Features', data.model.features?.join(', ') || 'Standard']
    ];

    this.autoTable(this.doc, {
      startY: yPos,
      body: modelDetails,
      theme: 'plain',
      styles: {
        fontSize: 11,
        cellPadding: 4
      },
      columnStyles: {
        0: { fontStyle: 'bold', cellWidth: 40 },
        1: { cellWidth: 'auto' }
      },
      margin: { left: this.margin, right: this.margin },
      didDrawPage: (data: any) => {
        this.lastTableY = data.cursor.y;
      }
    });

    yPos = this.lastTableY + 20;

    // Usage parameters section
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Usage Parameters', this.margin, yPos);
    yPos += 15;

    const usageParams = [
      ['Queries per Day', formatNumber(data.queriesPerDay)],
      ['Input Tokens per Query', formatNumber(data.inputTokensPerQuery)],
      ['Output Tokens per Query', formatNumber(data.outputTokensPerQuery)],
      ['Conversation History Tokens', formatNumber(data.conversationHistoryTokens)],
      ['Total Input Tokens/Day', formatNumber((data.inputTokensPerQuery + data.conversationHistoryTokens) * data.queriesPerDay)],
      ['Total Output Tokens/Day', formatNumber(data.outputTokensPerQuery * data.queriesPerDay)]
    ];

    this.autoTable(this.doc, {
      startY: yPos,
      body: usageParams,
      theme: 'plain',
      styles: {
        fontSize: 11,
        cellPadding: 4
      },
      columnStyles: {
        0: { fontStyle: 'bold', cellWidth: 60 },
        1: { cellWidth: 'auto', halign: 'right' }
      },
      margin: { left: this.margin, right: this.margin },
      didDrawPage: (data: any) => {
        this.lastTableY = data.cursor.y;
      }
    });

    yPos = this.lastTableY + 20;

    // Cost breakdown section
    this.doc.setFontSize(16);
    this.doc.setFont('helvetica', 'bold');
    this.doc.text('Cost Breakdown', this.margin, yPos);
    yPos += 15;

    const costData = [
      ['Period', 'Base Cost', 'With History', 'Difference'],
      ['Daily', formatCurrency(data.dailyCost), data.withHistoryCosts ? formatCurrency(data.withHistoryCosts.dailyCost) : '-', data.withHistoryCosts ? formatCurrency(data.withHistoryCosts.dailyCost - data.dailyCost) : '-'],
      ['Monthly (30 days)', formatCurrency(data.monthlyCost), data.withHistoryCosts ? formatCurrency(data.withHistoryCosts.monthlyCost) : '-', data.withHistoryCosts ? formatCurrency(data.withHistoryCosts.monthlyCost - data.monthlyCost) : '-'],
      ['Yearly (365 days)', formatCurrency(data.yearlyCost), data.withHistoryCosts ? formatCurrency(data.withHistoryCosts.yearlyCost) : '-', data.withHistoryCosts ? formatCurrency(data.withHistoryCosts.yearlyCost - data.yearlyCost) : '-']
    ];

    this.autoTable(this.doc, {
      startY: yPos,
      head: [costData[0]],
      body: costData.slice(1),
      theme: 'striped',
      headStyles: {
        fillColor: [59, 130, 246],
        textColor: [255, 255, 255],
        fontStyle: 'bold',
        fontSize: 11
      },
      bodyStyles: {
        fontSize: 11,
        cellPadding: 4
      },
      columnStyles: {
        0: { fontStyle: 'bold' },
        1: { halign: 'right' },
        2: { halign: 'right' },
        3: { halign: 'right', fillColor: data.withHistoryCosts ? [255, 248, 220] : [255, 255, 255] }
      },
      margin: { left: this.margin, right: this.margin },
      didDrawPage: (tableData: any) => {
        this.lastTableY = tableData.cursor.y;
      }
    });

    // Recommendations section
    if (this.lastTableY < this.pageHeight - 80) {
      yPos = this.lastTableY + 20;
      
      this.doc.setFontSize(14);
      this.doc.setFont('helvetica', 'bold');
      this.doc.text('Recommendations', this.margin, yPos);
      yPos += 10;

      this.doc.setFontSize(11);
      this.doc.setFont('helvetica', 'normal');
      this.doc.setTextColor(60, 60, 60);

      const recommendations = [];
      
      if (data.conversationHistoryTokens > 0 && data.withHistoryCosts) {
        const historyImpact = ((data.withHistoryCosts.yearlyCost / data.yearlyCost - 1) * 100).toFixed(1);
        recommendations.push(`• Conversation history adds ${historyImpact}% to annual costs`);
        recommendations.push(`• Consider optimizing history length to balance context vs. cost`);
      }
      
      if (data.yearlyCost > 10000) {
        recommendations.push(`• High annual cost (${formatCurrency(data.yearlyCost)}) - consider volume discounts`);
      }
      
      recommendations.push(`• Monitor usage patterns to optimize token efficiency`);
      recommendations.push(`• Consider model alternatives for different use cases`);

      recommendations.forEach(rec => {
        this.doc.text(rec, this.margin, yPos);
        yPos += 7;
      });
    }

    this.addFooter();
    this.doc.save(`Usage_Estimate_${data.model.name.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.pdf`);
  }
}

// Export functions
export const exportComparisonToPDF = async (data: ComparisonExportData) => {
  const exporter = new PDFExporter();
  await exporter.exportModelComparison(data);
};

export const exportUsageEstimateToPDF = async (data: UsageEstimateExportData) => {
  const exporter = new PDFExporter();
  await exporter.exportUsageEstimate(data);
};

export { PDFExporter };
export type { ComparisonExportData, UsageEstimateExportData };